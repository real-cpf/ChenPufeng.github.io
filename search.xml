<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/06/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Hexo-Quick-Start"><a href="#Hexo-Quick-Start" class="headerlink" title="Hexo Quick Start"></a>Hexo Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>sys</category>
      </categories>
      <tags>
        <tag>sys</tag>
      </tags>
  </entry>
  <entry>
    <title>os-1</title>
    <url>/2020/06/15/os-1/</url>
    <content><![CDATA[<h2 id="这个一个关于操作系统的系列，主要以笔者使用操作系统的感悟体验为先。"><a href="#这个一个关于操作系统的系列，主要以笔者使用操作系统的感悟体验为先。" class="headerlink" title="这个一个关于操作系统的系列，主要以笔者使用操作系统的感悟体验为先。"></a>这个一个关于操作系统的系列，主要以笔者使用操作系统的感悟体验为先。</h2><a id="more"></a>

<ul>
<li>起初使用的是window</li>
<li>开始接触linux</li>
<li>尝试不同的linux发行版</li>
<li>发现不同linux发行版的不同</li>
</ul>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>序言</tag>
      </tags>
  </entry>
  <entry>
    <title>post-one</title>
    <url>/2020/06/15/post-one/</url>
    <content><![CDATA[<h2 id="经过测试，发现新增文章要用posts"><a href="#经过测试，发现新增文章要用posts" class="headerlink" title="经过测试，发现新增文章要用posts"></a>经过测试，发现新增文章要用posts</h2><a id="more"></a>

<p>nothing</p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>os-hello-os</title>
    <url>/2020/06/15/os-hello-os/</url>
    <content><![CDATA[<h2 id="初识操作系统"><a href="#初识操作系统" class="headerlink" title="初识操作系统"></a>初识操作系统</h2><p> <code>本文主要介绍笔者对操作系统最初的认识，大多是感性的，借鉴性不强，可以略过。</code></p>
<a id="more"></a>

<p>笔者再了解计算机之前对计算机有种莫名的崇拜，在刚刚知道操作系统这个名词时，也是这种感觉。</p>
<p>我最初有意识认识到的操作系统是MTKOS，也就是凯斯系统，现在好像成为冒泡OS。</p>
<p>总之，当时我是在玩儿一个功能机，但不知为何找到了一个冒泡社区，后来就开始了操作系统的折腾。</p>
<p>当时的折腾也没有碰到内核，其实就是通过一个工程指令，打开冒泡社区。当时觉得比较酷的一次操作是，通过替换了一个文件，使得冒泡社区打开后成了iPhone那种滑动屏幕，然后可以在这个桌面上添加各种应用。其实就是把相应的文件放在规定的位置，桌面就能扫描出来了。</p>
<p>emm，这就是我与操作系统的初体验了。</p>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>序言</tag>
      </tags>
  </entry>
  <entry>
    <title>认识操作系统（一）</title>
    <url>/2020/06/15/%E8%AE%A4%E8%AF%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="认识操作系统（一）"><a href="#认识操作系统（一）" class="headerlink" title="认识操作系统（一）"></a>认识操作系统（一）</h2><p>本文将初步认识操作系统</p>
<a id="more"></a>


<img src="/2020/06/15/%E8%AE%A4%E8%AF%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/image-20200615183918527.png" class="" title="本篇对于操作系统的关注点">



<p><code>本篇将着重与上面几点进行关注</code></p>
<blockquote>
<p>认识操作系统系列参考书籍 <a href="https://legacy.gitbook.com/book/wizardforcel/think-os/details" target="_blank" rel="noopener">https://legacy.gitbook.com/book/wizardforcel/think-os/details</a></p>
</blockquote>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是资源分配的基本单位。</p>
<p>PCB作为进程的管理块保持着进程的基本信息与运行状态。</p>
<p>在linux下，这个块使用<code>task_struct</code>表示</p>
<p>结构体中的基本元素有：</p>
<blockquote>
<p>标识符：与进程相关的唯一标识符，用来区别正在执行的进程和其他进程。<br>状态：描述进程的状态，因为进程有挂起，阻塞，运行等好几个状态，所以都有个标识符来记录进程的执行状态。<br>优先级：如果有好几个进程正在执行，就涉及到进程被执行的先后顺序的问题，这和进程优先级这个标识符有关。<br>程序计数器：程序中即将被执行的下一条指令的地址。<br>内存指针：程序代码和进程相关数据的指针。<br>上下文数据：进程执行时处理器的寄存器中的数据。<br>I/O状态信息：包括显示的I/O请求，分配给进程的I/O设备和被进程使用的文件列表等。<br>记账信息：包括处理器的时间总和，记账号等等。</p>
<hr>
<p>原文链接：<a href="https://blog.csdn.net/bit_clearoff/java/article/details/54292300" target="_blank" rel="noopener">https://blog.csdn.net/bit_clearoff/java/article/details/54292300</a></p>
</blockquote>
<p><code>fork()</code></p>
<p><code>（通过复制调用生成一个新的进程）创建一个子进程。
   对于父进程来说，fork()的返回值是子进程的pid
   对于子进程来说，fork()的返回值是0</code></p>
<h3 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h3><ul>
<li><p>编写了一个监控程序，如果发现某个程序暂时无须使用 CPU 时，监控程序就把另外的正在等待 CPU 资源的程序启动起来，以充分利用 CPU 资源。这种方法被称为 <strong>多道程序（Multiprogramming）</strong></p>
</li>
<li><p>使得每个程序运行一段时间之后，都主动让出 CPU 资源，这样每个程序在一段时间内都有机会运行一小段时间,这种程序协作方式被称为 <strong>分时系统（Time-Sharing System）</strong></p>
</li>
<li><p>如果操作系统分配给各个进程的运行时间都很短，CPU 可以在多个进程间快速切换，就像很多进程都同时在运行的样子。也就是我们现在很熟悉的 <strong>多任务（Multi-tasking）系统</strong></p>
</li>
<li><p>中断 </p>
<blockquote>
<ol>
<li>当中断发生时,硬件将程序计数器保存到一个特殊的寄存器中,并且跳到合适的中断处<br>理器。</li>
<li>中断处理器将程序计数器和位寄存器,以及任何打算使用的数据寄存器的内容储存到内<br>存中。</li>
<li>中断处理器运行处理中断所需的代码。</li>
<li>之后它复原所保存寄存器的内容。最后,复原被中断进程的程序计数器,这会跳回到被<br>中断的进程。</li>
</ol>
</blockquote>
</li>
<li><p>上下文切换</p>
<blockquote>
<p>但是当中断发生时,内核并不总会恢复被中断的进程。它可以选择切换到其它进程,这种机制叫做“上下文切换”。</p>
</blockquote>
</li>
<li><p>生命周期</p>
<blockquote>
<ul>
<li>运行(Running),如果进程正在运行于某个核心上。<br>就绪(Ready),如果进程可以但没有运行,通常由于就绪进程数量大于内核的数量。</li>
<li>阻塞(Blocked),如果进程由于正在等待未来的事件,例如网络通信或磁盘读取,而不能运行。</li>
<li>终止(Done):如果进程运行完毕,但是带有没有读取的退出状态信息。</li>
<li>一个进程在运行中的程序执行类似于fork的系统调用时诞生。在系统调用的末尾,新的进程通常就绪。之后调度器可能恢复原有的进程(“父进程”),或者启动新的进程(“子进程”)。</li>
<li>当一个进程由调度器启动或恢复时,它的状态从就绪变为运行。</li>
<li>当一个进程被中断,并且调度器没有选择使它恢复,它的状态从运行变成就绪。</li>
<li>如果一个进程执行不能立即完成的系统调用,例如磁盘请求,它会变为阻塞,并且调度器会选择另一个进程。</li>
<li>当类似于磁盘请求的操作完成时,会产生中断。中断处理器弄清楚哪个进程正在等待请求,并将它的状态从阻塞变为就绪。<br>当一个进程调用exit时,中断处理器在PCB中储存退出代码,并将进程的状态变为终止。</li>
</ul>
</blockquote>
</li>
<li><p>调度</p>
<blockquote>
<ul>
<li>具有较高优先级的进程通常运行较快。</li>
<li>如果一个进程在时间片结束之前发出请求并被阻塞,就可能是IO密集型程序或交互型程序,优先级应该升高。</li>
<li>如果一个进程在整个时间片中都运行,就可能是长时间运行的计算密集型程序,优先级应该降低。</li>
<li>如果一个任务长时间被阻塞,之后变为就绪,它应该提升为最高优先级,便于响应所等待的东西。</li>
<li>如果进程A在等待进程B的过程中被阻塞,例如,如果它们由管道连接,进程B的优先级应升高。</li>
<li>系统调用nice允许进程降低(但不能升高)自己的优先级,并允许程序员向调度器传递显式的信息。</li>
</ul>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title>认识操作系统（二）</title>
    <url>/2020/06/16/%E8%AE%A4%E8%AF%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="认识操作系统（二）"><a href="#认识操作系统（二）" class="headerlink" title="认识操作系统（二）"></a>认识操作系统（二）</h2><p>接上文</p>
<a id="more"></a>

<blockquote>
<p>认识操作系统系列参考书籍 <a href="https://legacy.gitbook.com/book/wizardforcel/think-os/details" target="_blank" rel="noopener">https://legacy.gitbook.com/book/wizardforcel/think-os/details</a></p>
</blockquote>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li>缓存考量<blockquote>
<ul>
<li>谁在层次结构中上移或下移数据?在结构的顶端,寄存器通常由编译器完成分配。CPU上的硬件管理内存的缓存。在执行程序或打开文件的过程中,用户可以将存储器上的文件隐式移动到内存中。但是操作系统也会将数据从内存移动回存储器。在层次结构的底端,管理员在磁带和磁盘之间显式移动数据。</li>
<li>移动了什么东西?通常,在结构顶端的块大小比底端要小。在内存的缓存中,通常块大小为128B。内存中的页面可能为4KiB,但是当操作系统从磁盘读取文件时,它可能会一次读10或100个块。</li>
<li>数据什么时候会移动?在多数的基本的缓存中,数据在首次使用时会移到缓存。但是许多缓存使用一些“预取”机制,也就是说数据会在显式请求之前加载。我们已经见过预取的一些形式了:在请求其一部分时加载整个块。</li>
<li>缓存中数据在什么地方?当缓存填满之后,我们不把一些东西扔掉就不可能放进一些东西。理想化来说,我们打算保留将要用到的数据,并替换掉不会用到的数据。</li>
</ul>
</blockquote>
</li>
<li>页面调度<blockquote>
<ol>
<li>进程A调用用sbrkmalloc来分配页面。如果堆中没有所请求大小的空闲空间,malloc会调向操作系统请求更多内存。</li>
<li>如果物理内存中有空闲页,操作系统会将其加载到进程A的页表,创建新的虚拟内存有效范围。</li>
<li>如果没有空闲页面,调度系统会选择一个属于进程B的“牺牲页面”。它将页面内容从内存复制到磁盘,之后修改进程B的页表来表示这个页面“被换出”了。</li>
<li>一旦进程B的数据被写入,页面会重新分配给进程A。为了防止进程A读取进程B的数据,页面应被清空。</li>
<li>此时sbrk的调用可以返回了,向malloc提供堆区额外的空间。之后malloc分配所请求的内存并返回。进程A可以继续执行。</li>
<li>当进程A执行完毕,或中断后,调度器可能会让进程B继续执行。当它访问到被换出的页面时,内存管理器单元注意到这个页面是“无效”的,并且会触发中断。</li>
<li>当操作系统处理中断时,它会看到页面被换出了,于是它将页面从磁盘传送到内存。</li>
<li>一旦页面被换入之后,进程B可以继续执行。</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><ul>
<li>地址空间<blockquote>
<p>主存中的每个字节都由一个“物理地址”整数所指定,物理地址的集合叫做物理“地址空间”。它的范围通常为0到 N-1址是 ,十进制表示为1,073,741,823,16进制表示为0x03ff ffff(前缀2 ** 30 - 1,其中N是主存的大小。在带有1GiB主存的的系统上,最的有效地0x表示十六进制)。</p>
</blockquote>
</li>
<li>内存段<blockquote>
<ul>
<li>text段包含程序文本,即程序所组成的机器语言指令<code>靠近内存“底部”,即接近0的地址。</code></li>
<li>static 段包含由编译器所分配的变量,包括全局变量,和使用  static声明的局部变量。<code>常刚好在text段上面。</code></li>
<li>stack段包含运行时栈,它由栈帧组成。每个栈帧包含函参数、本地变量以及其它。<code>靠近内存顶部,即接近虚拟地址空间的最大地址。在扩张过程中,它向低地址的方向增长。</code></li>
<li>heap段包含运行时分配的内存块,通常通过调用C标准函数malloc来分配。<code>通常在static段的上面。在扩张过程中,它向高地址的方向增长</code></li>
</ul>
</blockquote>
</li>
<li>地址翻译<blockquote>
<p>虚拟地址(VA)  成物理地址(PA)  内存管理单元(MMU)</p>
<ol>
<li>当程序读写变量时,CPU会得到VA。</li>
<li>MMU将VA分成两部分,称为页码和偏移。“页”是一个内存块,页的大小取决于操作系统和硬件,通常为1~4KiB。</li>
<li>MMU在“页表”里查找页码,然后获取相应的物理页码。之后它将物理页码和偏移组合得到PA。</li>
<li>PA传递给主存,用于读写指定地址。</li>
</ol>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title>认识操作系统（三）</title>
    <url>/2020/06/16/%E8%AE%A4%E8%AF%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="认识操作系统（三）"><a href="#认识操作系统（三）" class="headerlink" title="认识操作系统（三）"></a>认识操作系统（三）</h2><p>接上文</p>
<a id="more"></a>
<blockquote>
<p>认识操作系统系列参考书籍 <a href="https://legacy.gitbook.com/book/wizardforcel/think-os/details" target="_blank" rel="noopener">https://legacy.gitbook.com/book/wizardforcel/think-os/details</a></p>
</blockquote>
<h3 id="文件与文件系统"><a href="#文件与文件系统" class="headerlink" title="文件与文件系统"></a>文件与文件系统</h3><blockquote>
<ul>
<li>Windows: FAT, FAT16, FAT32, NTFS </li>
<li>Linux: ext2/3/4, btrfs, ZFS</li>
<li>Mac OS X: HFS+</li>
</ul>
</blockquote>
<ul>
<li>“文件系统”将每个文件的名称映射到它的内容。如果你认为名称是键,内容是值,文件系统就是一种键值对的数据库。“文件”就是一组字节序列</li>
<li>磁盘阵列（Redundant Arrays of Independent Disks，RAID），独立冗余磁盘阵列之。原理是利用数组方式来作磁盘组，配合数据分散排列的设计，提升数据的安全性。</li>
<li>主存和持久化储存器的性能间隔是计算机系统的主要挑战之一。操作系统和硬件提供了一些特性来“填补”这一间隔。</li>
<li>块的传输:从磁盘加载一个字节的时间是5毫秒。相比之下,加载一个8KiB的块所需的时间是微不足道的。如果处理器在每个块上都要花费5毫秒,就有可能使处理器保持忙碌。</li>
<li>预取:有时操作系统可以预测到进程会读取某个块,并且在它请求之前就开始加载了。例如,如果你打开一个文件并读取首个块,操作系统可能会在请求之前开始加载额外的块。</li>
<li>缓冲:像我提到过的那样,当你写入一个文件时,操作系统会先把数据放在内存中,并且稍后写到磁盘。如果某个块在内存中时,你对其做数次修改,系统只需要写到磁盘一次。<h3 id="位与字节"><a href="#位与字节" class="headerlink" title="位与字节"></a>位与字节</h3></li>
<li>数值表示</li>
<li>安位运算</li>
</ul>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title>认识操作系统（四）</title>
    <url>/2020/06/17/%E8%AE%A4%E8%AF%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h2 id="认识操作系统（四）"><a href="#认识操作系统（四）" class="headerlink" title="认识操作系统（四）"></a>认识操作系统（四）</h2><p>接上文</p>
<a id="more"></a>
<blockquote>
<p>认识操作系统系列参考书籍 <a href="https://legacy.gitbook.com/book/wizardforcel/think-os/details" target="_blank" rel="noopener">https://legacy.gitbook.com/book/wizardforcel/think-os/details</a></p>
</blockquote>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li>线程是资源调度的独立单位</li>
<li>创建进程时,操作系统会创建一块新的地址空间,它包含text段、static段、和堆区。它也会创建新的“执行线程”,这包括程序计器和其它硬件状态,以及运行时栈。</li>
<li>线程间通信</li>
<li>多线程</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul>
<li>内存安全 Memory safety is the state of being protected fromvarious software bugs and security vulnerabilities whendealing with memory access, such as buffer overflowsand dangling pointers.<code>建议参考rust的零成本抽象设计</code></li>
</ul>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title>octave-matlab-base-01</title>
    <url>/2020/06/23/octave-matlab-base-01/</url>
    <content><![CDATA[<h2 id="用octave实现matlab基本功能"><a href="#用octave实现matlab基本功能" class="headerlink" title="用octave实现matlab基本功能"></a>用octave实现matlab基本功能</h2><blockquote>
<p>参考《精通matlab》</p>
</blockquote>
<a id="more"></a>

<ol>
<li>数学表达式(单行、多行)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% calc</span><br><span class="line">(12+2*(7-4))&#x2F;3^2 </span><br><span class="line">%% Multiline input</span><br><span class="line">S&#x3D;1-1&#x2F;2+1&#x2F;3-1&#x2F;4+ ...</span><br><span class="line">1&#x2F;5-1&#x2F;6+1&#x2F;7-1&#x2F;8</span><br></pre></td></tr></table></figure></li>
<li>常用变量</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% variable</span><br><span class="line">eps</span><br><span class="line">NaN</span><br><span class="line">realmax</span><br><span class="line">realmin</span><br><span class="line">intmin</span><br><span class="line">intmax</span><br><span class="line"></span><br><span class="line">format short e</span><br><span class="line">RMAd&#x3D;realmax(&#39;double&#39;)		</span><br><span class="line">RMAs&#x3D;realmax(&#39;single&#39;)		</span><br><span class="line">format long e</span><br><span class="line">IMA64&#x3D;intmax(&#39;int64&#39;)			</span><br><span class="line">IMA32&#x3D;intmax					 </span><br><span class="line">IMA32&#x3D;intmax(&#39;int16&#39;)			  </span><br><span class="line">format short e</span><br><span class="line">e1&#x3D;eps							 </span><br><span class="line">e2&#x3D;eps(2)	          </span><br><span class="line">pi</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>操作符</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a*b</span><br><span class="line">a.*b</span><br><span class="line">a&#x2F;b</span><br><span class="line">a.&#x2F;b</span><br><span class="line">a^b</span><br><span class="line">a.^b</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>复数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% complex</span><br><span class="line">z2 &#x3D; 1 + 2 * i				</span><br><span class="line">z3&#x3D;2*exp(i*pi&#x2F;6)			</span><br><span class="line">z&#x3D;z1*z2&#x2F;z3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>图示z1=4+3i,z2=1+2i 的和</p>
</blockquote>
<img src="/2020/06/23/octave-matlab-base-01/tu1.png" class="" title="z1&#x3D;4+3i,z2&#x3D;1+2i">


<ol start="5">
<li>计算sqrt(-8,3)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% get sqrt(-8,3)</span><br><span class="line">a&#x3D;-8</span><br><span class="line">r_a&#x3D;a^(1&#x2F;3)</span><br><span class="line"></span><br><span class="line">p&#x3D;[1,0,0,-a]</span><br><span class="line"></span><br><span class="line">R&#x3D;roots(p)</span><br><span class="line"></span><br><span class="line">MR&#x3D;abs(R(1));		%</span><br><span class="line">t&#x3D;0:pi&#x2F;20:2*pi;	%</span><br><span class="line">x&#x3D;MR*sin(t);		</span><br><span class="line">y&#x3D;MR*cos(t);		</span><br><span class="line">plot(x,y,&#39;b:&#39;),grid on		%</span><br><span class="line">								%</span><br><span class="line">hold on</span><br><span class="line">plot(R(2),&#39;.&#39;,&#39;MarkerSize&#39;,30,&#39;Color&#39;,&#39;r&#39;)			%</span><br><span class="line">plot(R([1,3]),&#39;o&#39;,&#39;MarkerSize&#39;,15,&#39;Color&#39;,&#39;b&#39;)	%</span><br><span class="line">axis([-3,3,-3,3]),axis square						%</span><br><span class="line">hold off</span><br></pre></td></tr></table></figure>
<img src="/2020/06/23/octave-matlab-base-01/tu2.png" class="" title="sqrt(-8,3)">

<ol start="6">
<li>矩阵</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% matrix</span><br><span class="line"></span><br><span class="line">AR&#x3D;[1,3;2,4]</span><br><span class="line">AI&#x3D;[1,2</span><br><span class="line">    3,4]</span><br><span class="line"></span><br><span class="line">%% A&#x3D;[1-5i,3-7i</span><br><span class="line">%%    2-6i,4-8i]</span><br><span class="line">%% 实部、虚部、模和幅角</span><br><span class="line">    </span><br><span class="line">AR&#x3D;[1,3;2,4];AI&#x3D;[5,7;6,8];</span><br><span class="line">A&#x3D;AR-AI*i						%</span><br><span class="line"></span><br><span class="line">A_real&#x3D;real(A)</span><br><span class="line">A_image&#x3D;imag(A)  </span><br><span class="line"></span><br><span class="line">for m&#x3D;1:2</span><br><span class="line">for n&#x3D;1:2</span><br><span class="line">		Am1(m,n)&#x3D;abs(A(m,n));</span><br><span class="line">		Aa1(m,n)&#x3D;angle(A(m,n))*180&#x2F;pi;	%</span><br><span class="line">	end</span><br><span class="line">end</span><br><span class="line">Am1,Aa1  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Am2&#x3D;abs(A)</span><br><span class="line">Aa2&#x3D;angle(A)*180&#x2F;pi</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>衰减振荡曲线  y=e^(1/3)*sin(3t)  t=[0:4pi]</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t&#x3D;0:pi&#x2F;50:4*pi;			</span><br><span class="line">y&#x3D;exp(-t&#x2F;3).*sin(3*t);	</span><br><span class="line">plot(t,y,&#39;-r&#39;,&#39;LineWidth&#39;,2)				</span><br><span class="line">axis([0,4*pi,-1,1])</span><br><span class="line">xlabel(&#39;t&#39;),ylabel(&#39;y&#39;)</span><br></pre></td></tr></table></figure>


<img src="/2020/06/23/octave-matlab-base-01/tu3.png" class="" title="衰减振荡曲线">


<ol start="8">
<li>函数文档</li>
</ol>
<img src="/2020/06/23/octave-matlab-base-01/tu4.png" class="" title="函数文档">

<ol start="9">
<li>工作变量</li>
</ol>
<img src="/2020/06/23/octave-matlab-base-01/tu5.png" class="" title="工作变量">


<blockquote>
<p>octave 代码  <a href="https://github.com/real-cpf/octave-matlab" target="_blank" rel="noopener">https://github.com/real-cpf/octave-matlab</a></p>
</blockquote>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>octave</tag>
      </tags>
  </entry>
</search>
