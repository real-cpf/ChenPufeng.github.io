<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/06/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Hexo-Quick-Start"><a href="#Hexo-Quick-Start" class="headerlink" title="Hexo Quick Start"></a>Hexo Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>sys</category>
      </categories>
      <tags>
        <tag>sys</tag>
      </tags>
  </entry>
  <entry>
    <title>os-1</title>
    <url>/2020/06/15/os-1/</url>
    <content><![CDATA[<h2 id="这个一个关于操作系统的系列，主要以笔者使用操作系统的感悟体验为先。"><a href="#这个一个关于操作系统的系列，主要以笔者使用操作系统的感悟体验为先。" class="headerlink" title="这个一个关于操作系统的系列，主要以笔者使用操作系统的感悟体验为先。"></a>这个一个关于操作系统的系列，主要以笔者使用操作系统的感悟体验为先。</h2><a id="more"></a>

<ul>
<li>起初使用的是window</li>
<li>开始接触linux</li>
<li>尝试不同的linux发行版</li>
<li>发现不同linux发行版的不同</li>
</ul>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>序言</tag>
      </tags>
  </entry>
  <entry>
    <title>post-one</title>
    <url>/2020/06/15/post-one/</url>
    <content><![CDATA[<h2 id="经过测试，发现新增文章要用posts"><a href="#经过测试，发现新增文章要用posts" class="headerlink" title="经过测试，发现新增文章要用posts"></a>经过测试，发现新增文章要用posts</h2><a id="more"></a>

<p>nothing</p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>os-hello-os</title>
    <url>/2020/06/15/os-hello-os/</url>
    <content><![CDATA[<h2 id="初识操作系统"><a href="#初识操作系统" class="headerlink" title="初识操作系统"></a>初识操作系统</h2><p> <code>本文主要介绍笔者对操作系统最初的认识，大多是感性的，借鉴性不强，可以略过。</code></p>
<a id="more"></a>

<p>笔者再了解计算机之前对计算机有种莫名的崇拜，在刚刚知道操作系统这个名词时，也是这种感觉。</p>
<p>我最初有意识认识到的操作系统是MTKOS，也就是凯斯系统，现在好像成为冒泡OS。</p>
<p>总之，当时我是在玩儿一个功能机，但不知为何找到了一个冒泡社区，后来就开始了操作系统的折腾。</p>
<p>当时的折腾也没有碰到内核，其实就是通过一个工程指令，打开冒泡社区。当时觉得比较酷的一次操作是，通过替换了一个文件，使得冒泡社区打开后成了iPhone那种滑动屏幕，然后可以在这个桌面上添加各种应用。其实就是把相应的文件放在规定的位置，桌面就能扫描出来了。</p>
<p>emm，这就是我与操作系统的初体验了。</p>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>序言</tag>
      </tags>
  </entry>
  <entry>
    <title>认识操作系统（一）</title>
    <url>/2020/06/15/%E8%AE%A4%E8%AF%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="认识操作系统（一）"><a href="#认识操作系统（一）" class="headerlink" title="认识操作系统（一）"></a>认识操作系统（一）</h2><p>本文将初步认识操作系统</p>
<a id="more"></a>


<img src="/2020/06/15/%E8%AE%A4%E8%AF%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/image-20200615183918527.png" class="" title="本篇对于操作系统的关注点">



<p><code>本篇将着重与上面几点进行关注</code></p>
<blockquote>
<p>认识操作系统系列参考书籍 <a href="https://legacy.gitbook.com/book/wizardforcel/think-os/details" target="_blank" rel="noopener">https://legacy.gitbook.com/book/wizardforcel/think-os/details</a></p>
</blockquote>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是资源分配的基本单位。</p>
<p>PCB作为进程的管理块保持着进程的基本信息与运行状态。</p>
<p>在linux下，这个块使用<code>task_struct</code>表示</p>
<p>结构体中的基本元素有：</p>
<blockquote>
<p>标识符：与进程相关的唯一标识符，用来区别正在执行的进程和其他进程。<br>状态：描述进程的状态，因为进程有挂起，阻塞，运行等好几个状态，所以都有个标识符来记录进程的执行状态。<br>优先级：如果有好几个进程正在执行，就涉及到进程被执行的先后顺序的问题，这和进程优先级这个标识符有关。<br>程序计数器：程序中即将被执行的下一条指令的地址。<br>内存指针：程序代码和进程相关数据的指针。<br>上下文数据：进程执行时处理器的寄存器中的数据。<br>I/O状态信息：包括显示的I/O请求，分配给进程的I/O设备和被进程使用的文件列表等。<br>记账信息：包括处理器的时间总和，记账号等等。</p>
<hr>
<p>原文链接：<a href="https://blog.csdn.net/bit_clearoff/java/article/details/54292300" target="_blank" rel="noopener">https://blog.csdn.net/bit_clearoff/java/article/details/54292300</a></p>
</blockquote>
<p><code>fork()</code></p>
<p><code>（通过复制调用生成一个新的进程）创建一个子进程。
   对于父进程来说，fork()的返回值是子进程的pid
   对于子进程来说，fork()的返回值是0</code></p>
<h3 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h3><ul>
<li><p>编写了一个监控程序，如果发现某个程序暂时无须使用 CPU 时，监控程序就把另外的正在等待 CPU 资源的程序启动起来，以充分利用 CPU 资源。这种方法被称为 <strong>多道程序（Multiprogramming）</strong></p>
</li>
<li><p>使得每个程序运行一段时间之后，都主动让出 CPU 资源，这样每个程序在一段时间内都有机会运行一小段时间,这种程序协作方式被称为 <strong>分时系统（Time-Sharing System）</strong></p>
</li>
<li><p>如果操作系统分配给各个进程的运行时间都很短，CPU 可以在多个进程间快速切换，就像很多进程都同时在运行的样子。也就是我们现在很熟悉的 <strong>多任务（Multi-tasking）系统</strong></p>
</li>
<li><p>中断 </p>
<blockquote>
<ol>
<li>当中断发生时,硬件将程序计数器保存到一个特殊的寄存器中,并且跳到合适的中断处<br>理器。</li>
<li>中断处理器将程序计数器和位寄存器,以及任何打算使用的数据寄存器的内容储存到内<br>存中。</li>
<li>中断处理器运行处理中断所需的代码。</li>
<li>之后它复原所保存寄存器的内容。最后,复原被中断进程的程序计数器,这会跳回到被<br>中断的进程。</li>
</ol>
</blockquote>
</li>
<li><p>上下文切换</p>
<blockquote>
<p>但是当中断发生时,内核并不总会恢复被中断的进程。它可以选择切换到其它进程,这种机制叫做“上下文切换”。</p>
</blockquote>
</li>
<li><p>生命周期</p>
<blockquote>
<ul>
<li>运行(Running),如果进程正在运行于某个核心上。<br>就绪(Ready),如果进程可以但没有运行,通常由于就绪进程数量大于内核的数量。</li>
<li>阻塞(Blocked),如果进程由于正在等待未来的事件,例如网络通信或磁盘读取,而不能运行。</li>
<li>终止(Done):如果进程运行完毕,但是带有没有读取的退出状态信息。</li>
<li>一个进程在运行中的程序执行类似于fork的系统调用时诞生。在系统调用的末尾,新的进程通常就绪。之后调度器可能恢复原有的进程(“父进程”),或者启动新的进程(“子进程”)。</li>
<li>当一个进程由调度器启动或恢复时,它的状态从就绪变为运行。</li>
<li>当一个进程被中断,并且调度器没有选择使它恢复,它的状态从运行变成就绪。</li>
<li>如果一个进程执行不能立即完成的系统调用,例如磁盘请求,它会变为阻塞,并且调度器会选择另一个进程。</li>
<li>当类似于磁盘请求的操作完成时,会产生中断。中断处理器弄清楚哪个进程正在等待请求,并将它的状态从阻塞变为就绪。<br>当一个进程调用exit时,中断处理器在PCB中储存退出代码,并将进程的状态变为终止。</li>
</ul>
</blockquote>
</li>
<li><p>调度</p>
<blockquote>
<ul>
<li>具有较高优先级的进程通常运行较快。</li>
<li>如果一个进程在时间片结束之前发出请求并被阻塞,就可能是IO密集型程序或交互型程序,优先级应该升高。</li>
<li>如果一个进程在整个时间片中都运行,就可能是长时间运行的计算密集型程序,优先级应该降低。</li>
<li>如果一个任务长时间被阻塞,之后变为就绪,它应该提升为最高优先级,便于响应所等待的东西。</li>
<li>如果进程A在等待进程B的过程中被阻塞,例如,如果它们由管道连接,进程B的优先级应升高。</li>
<li>系统调用nice允许进程降低(但不能升高)自己的优先级,并允许程序员向调度器传递显式的信息。</li>
</ul>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title>认识操作系统（二）</title>
    <url>/2020/06/16/%E8%AE%A4%E8%AF%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="认识操作系统（二）"><a href="#认识操作系统（二）" class="headerlink" title="认识操作系统（二）"></a>认识操作系统（二）</h2><p>接上文</p>
<a id="more"></a>

<blockquote>
<p>认识操作系统系列参考书籍 <a href="https://legacy.gitbook.com/book/wizardforcel/think-os/details" target="_blank" rel="noopener">https://legacy.gitbook.com/book/wizardforcel/think-os/details</a></p>
</blockquote>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li>缓存考量<blockquote>
<ul>
<li>谁在层次结构中上移或下移数据?在结构的顶端,寄存器通常由编译器完成分配。CPU上的硬件管理内存的缓存。在执行程序或打开文件的过程中,用户可以将存储器上的文件隐式移动到内存中。但是操作系统也会将数据从内存移动回存储器。在层次结构的底端,管理员在磁带和磁盘之间显式移动数据。</li>
<li>移动了什么东西?通常,在结构顶端的块大小比底端要小。在内存的缓存中,通常块大小为128B。内存中的页面可能为4KiB,但是当操作系统从磁盘读取文件时,它可能会一次读10或100个块。</li>
<li>数据什么时候会移动?在多数的基本的缓存中,数据在首次使用时会移到缓存。但是许多缓存使用一些“预取”机制,也就是说数据会在显式请求之前加载。我们已经见过预取的一些形式了:在请求其一部分时加载整个块。</li>
<li>缓存中数据在什么地方?当缓存填满之后,我们不把一些东西扔掉就不可能放进一些东西。理想化来说,我们打算保留将要用到的数据,并替换掉不会用到的数据。</li>
</ul>
</blockquote>
</li>
<li>页面调度<blockquote>
<ol>
<li>进程A调用用sbrkmalloc来分配页面。如果堆中没有所请求大小的空闲空间,malloc会调向操作系统请求更多内存。</li>
<li>如果物理内存中有空闲页,操作系统会将其加载到进程A的页表,创建新的虚拟内存有效范围。</li>
<li>如果没有空闲页面,调度系统会选择一个属于进程B的“牺牲页面”。它将页面内容从内存复制到磁盘,之后修改进程B的页表来表示这个页面“被换出”了。</li>
<li>一旦进程B的数据被写入,页面会重新分配给进程A。为了防止进程A读取进程B的数据,页面应被清空。</li>
<li>此时sbrk的调用可以返回了,向malloc提供堆区额外的空间。之后malloc分配所请求的内存并返回。进程A可以继续执行。</li>
<li>当进程A执行完毕,或中断后,调度器可能会让进程B继续执行。当它访问到被换出的页面时,内存管理器单元注意到这个页面是“无效”的,并且会触发中断。</li>
<li>当操作系统处理中断时,它会看到页面被换出了,于是它将页面从磁盘传送到内存。</li>
<li>一旦页面被换入之后,进程B可以继续执行。</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><ul>
<li>地址空间<blockquote>
<p>主存中的每个字节都由一个“物理地址”整数所指定,物理地址的集合叫做物理“地址空间”。它的范围通常为0到 N-1址是 ,十进制表示为1,073,741,823,16进制表示为0x03ff ffff(前缀2 ** 30 - 1,其中N是主存的大小。在带有1GiB主存的的系统上,最的有效地0x表示十六进制)。</p>
</blockquote>
</li>
<li>内存段<blockquote>
<ul>
<li>text段包含程序文本,即程序所组成的机器语言指令<code>靠近内存“底部”,即接近0的地址。</code></li>
<li>static 段包含由编译器所分配的变量,包括全局变量,和使用  static声明的局部变量。<code>常刚好在text段上面。</code></li>
<li>stack段包含运行时栈,它由栈帧组成。每个栈帧包含函参数、本地变量以及其它。<code>靠近内存顶部,即接近虚拟地址空间的最大地址。在扩张过程中,它向低地址的方向增长。</code></li>
<li>heap段包含运行时分配的内存块,通常通过调用C标准函数malloc来分配。<code>通常在static段的上面。在扩张过程中,它向高地址的方向增长</code></li>
</ul>
</blockquote>
</li>
<li>地址翻译<blockquote>
<p>虚拟地址(VA)  成物理地址(PA)  内存管理单元(MMU)</p>
<ol>
<li>当程序读写变量时,CPU会得到VA。</li>
<li>MMU将VA分成两部分,称为页码和偏移。“页”是一个内存块,页的大小取决于操作系统和硬件,通常为1~4KiB。</li>
<li>MMU在“页表”里查找页码,然后获取相应的物理页码。之后它将物理页码和偏移组合得到PA。</li>
<li>PA传递给主存,用于读写指定地址。</li>
</ol>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title>认识操作系统（三）</title>
    <url>/2020/06/16/%E8%AE%A4%E8%AF%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="认识操作系统（三）"><a href="#认识操作系统（三）" class="headerlink" title="认识操作系统（三）"></a>认识操作系统（三）</h2><p>接上文</p>
<a id="more"></a>
<blockquote>
<p>认识操作系统系列参考书籍 <a href="https://legacy.gitbook.com/book/wizardforcel/think-os/details" target="_blank" rel="noopener">https://legacy.gitbook.com/book/wizardforcel/think-os/details</a></p>
</blockquote>
<h3 id="文件与文件系统"><a href="#文件与文件系统" class="headerlink" title="文件与文件系统"></a>文件与文件系统</h3><blockquote>
<ul>
<li>Windows: FAT, FAT16, FAT32, NTFS </li>
<li>Linux: ext2/3/4, btrfs, ZFS</li>
<li>Mac OS X: HFS+</li>
</ul>
</blockquote>
<ul>
<li>“文件系统”将每个文件的名称映射到它的内容。如果你认为名称是键,内容是值,文件系统就是一种键值对的数据库。“文件”就是一组字节序列</li>
<li>磁盘阵列（Redundant Arrays of Independent Disks，RAID），独立冗余磁盘阵列之。原理是利用数组方式来作磁盘组，配合数据分散排列的设计，提升数据的安全性。</li>
<li>主存和持久化储存器的性能间隔是计算机系统的主要挑战之一。操作系统和硬件提供了一些特性来“填补”这一间隔。</li>
<li>块的传输:从磁盘加载一个字节的时间是5毫秒。相比之下,加载一个8KiB的块所需的时间是微不足道的。如果处理器在每个块上都要花费5毫秒,就有可能使处理器保持忙碌。</li>
<li>预取:有时操作系统可以预测到进程会读取某个块,并且在它请求之前就开始加载了。例如,如果你打开一个文件并读取首个块,操作系统可能会在请求之前开始加载额外的块。</li>
<li>缓冲:像我提到过的那样,当你写入一个文件时,操作系统会先把数据放在内存中,并且稍后写到磁盘。如果某个块在内存中时,你对其做数次修改,系统只需要写到磁盘一次。<h3 id="位与字节"><a href="#位与字节" class="headerlink" title="位与字节"></a>位与字节</h3></li>
<li>数值表示</li>
<li>安位运算</li>
</ul>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title>认识操作系统（四）</title>
    <url>/2020/06/17/%E8%AE%A4%E8%AF%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h2 id="认识操作系统（四）"><a href="#认识操作系统（四）" class="headerlink" title="认识操作系统（四）"></a>认识操作系统（四）</h2><p>接上文</p>
<a id="more"></a>
<blockquote>
<p>认识操作系统系列参考书籍 <a href="https://legacy.gitbook.com/book/wizardforcel/think-os/details" target="_blank" rel="noopener">https://legacy.gitbook.com/book/wizardforcel/think-os/details</a></p>
</blockquote>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li>线程是资源调度的独立单位</li>
<li>创建进程时,操作系统会创建一块新的地址空间,它包含text段、static段、和堆区。它也会创建新的“执行线程”,这包括程序计器和其它硬件状态,以及运行时栈。</li>
<li>线程间通信</li>
<li>多线程</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul>
<li>内存安全 Memory safety is the state of being protected fromvarious software bugs and security vulnerabilities whendealing with memory access, such as buffer overflowsand dangling pointers.<code>建议参考rust的零成本抽象设计</code></li>
</ul>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title>octave-matlab-base-01</title>
    <url>/2020/06/23/octave-matlab-base-01/</url>
    <content><![CDATA[<h2 id="用octave实现matlab基本功能"><a href="#用octave实现matlab基本功能" class="headerlink" title="用octave实现matlab基本功能"></a>用octave实现matlab基本功能</h2><blockquote>
<p>参考《精通matlab》</p>
</blockquote>
<a id="more"></a>

<iframe src="//player.bilibili.com/player.html?aid=668554496&bvid=BV1Ja4y1Y7G6&cid=204943602&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ol>
<li>数学表达式(单行、多行)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% calc</span><br><span class="line">(12+2*(7-4))&#x2F;3^2 </span><br><span class="line">%% Multiline input</span><br><span class="line">S&#x3D;1-1&#x2F;2+1&#x2F;3-1&#x2F;4+ ...</span><br><span class="line">1&#x2F;5-1&#x2F;6+1&#x2F;7-1&#x2F;8</span><br></pre></td></tr></table></figure></li>
<li>常用变量</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% variable</span><br><span class="line">eps</span><br><span class="line">NaN</span><br><span class="line">realmax</span><br><span class="line">realmin</span><br><span class="line">intmin</span><br><span class="line">intmax</span><br><span class="line"></span><br><span class="line">format short e</span><br><span class="line">RMAd&#x3D;realmax(&#39;double&#39;)		</span><br><span class="line">RMAs&#x3D;realmax(&#39;single&#39;)		</span><br><span class="line">format long e</span><br><span class="line">IMA64&#x3D;intmax(&#39;int64&#39;)			</span><br><span class="line">IMA32&#x3D;intmax					 </span><br><span class="line">IMA32&#x3D;intmax(&#39;int16&#39;)			  </span><br><span class="line">format short e</span><br><span class="line">e1&#x3D;eps							 </span><br><span class="line">e2&#x3D;eps(2)	          </span><br><span class="line">pi</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>操作符</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a*b</span><br><span class="line">a.*b</span><br><span class="line">a&#x2F;b</span><br><span class="line">a.&#x2F;b</span><br><span class="line">a^b</span><br><span class="line">a.^b</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>复数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% complex</span><br><span class="line">z2 &#x3D; 1 + 2 * i				</span><br><span class="line">z3&#x3D;2*exp(i*pi&#x2F;6)			</span><br><span class="line">z&#x3D;z1*z2&#x2F;z3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>图示z1=4+3i,z2=1+2i 的和</p>
</blockquote>
<img src="/2020/06/23/octave-matlab-base-01/tu1.png" class="" title="z1&#x3D;4+3i,z2&#x3D;1+2i">


<ol start="5">
<li>计算sqrt(-8,3)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% get sqrt(-8,3)</span><br><span class="line">a&#x3D;-8</span><br><span class="line">r_a&#x3D;a^(1&#x2F;3)</span><br><span class="line"></span><br><span class="line">p&#x3D;[1,0,0,-a]</span><br><span class="line"></span><br><span class="line">R&#x3D;roots(p)</span><br><span class="line"></span><br><span class="line">MR&#x3D;abs(R(1));		%</span><br><span class="line">t&#x3D;0:pi&#x2F;20:2*pi;	%</span><br><span class="line">x&#x3D;MR*sin(t);		</span><br><span class="line">y&#x3D;MR*cos(t);		</span><br><span class="line">plot(x,y,&#39;b:&#39;),grid on		%</span><br><span class="line">								%</span><br><span class="line">hold on</span><br><span class="line">plot(R(2),&#39;.&#39;,&#39;MarkerSize&#39;,30,&#39;Color&#39;,&#39;r&#39;)			%</span><br><span class="line">plot(R([1,3]),&#39;o&#39;,&#39;MarkerSize&#39;,15,&#39;Color&#39;,&#39;b&#39;)	%</span><br><span class="line">axis([-3,3,-3,3]),axis square						%</span><br><span class="line">hold off</span><br></pre></td></tr></table></figure>
<img src="/2020/06/23/octave-matlab-base-01/tu2.png" class="" title="sqrt(-8,3)">

<ol start="6">
<li>矩阵</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% matrix</span><br><span class="line"></span><br><span class="line">AR&#x3D;[1,3;2,4]</span><br><span class="line">AI&#x3D;[1,2</span><br><span class="line">    3,4]</span><br><span class="line"></span><br><span class="line">%% A&#x3D;[1-5i,3-7i</span><br><span class="line">%%    2-6i,4-8i]</span><br><span class="line">%% 实部、虚部、模和幅角</span><br><span class="line">    </span><br><span class="line">AR&#x3D;[1,3;2,4];AI&#x3D;[5,7;6,8];</span><br><span class="line">A&#x3D;AR-AI*i						%</span><br><span class="line"></span><br><span class="line">A_real&#x3D;real(A)</span><br><span class="line">A_image&#x3D;imag(A)  </span><br><span class="line"></span><br><span class="line">for m&#x3D;1:2</span><br><span class="line">for n&#x3D;1:2</span><br><span class="line">		Am1(m,n)&#x3D;abs(A(m,n));</span><br><span class="line">		Aa1(m,n)&#x3D;angle(A(m,n))*180&#x2F;pi;	%</span><br><span class="line">	end</span><br><span class="line">end</span><br><span class="line">Am1,Aa1  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Am2&#x3D;abs(A)</span><br><span class="line">Aa2&#x3D;angle(A)*180&#x2F;pi</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>衰减振荡曲线  y=e^(1/3)*sin(3t)  t=[0:4pi]</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t&#x3D;0:pi&#x2F;50:4*pi;			</span><br><span class="line">y&#x3D;exp(-t&#x2F;3).*sin(3*t);	</span><br><span class="line">plot(t,y,&#39;-r&#39;,&#39;LineWidth&#39;,2)				</span><br><span class="line">axis([0,4*pi,-1,1])</span><br><span class="line">xlabel(&#39;t&#39;),ylabel(&#39;y&#39;)</span><br></pre></td></tr></table></figure>


<img src="/2020/06/23/octave-matlab-base-01/tu3.png" class="" title="衰减振荡曲线">


<ol start="8">
<li>函数文档</li>
</ol>
<img src="/2020/06/23/octave-matlab-base-01/tu4.png" class="" title="函数文档">

<ol start="9">
<li>工作变量</li>
</ol>
<img src="/2020/06/23/octave-matlab-base-01/tu5.png" class="" title="工作变量">



<blockquote>
<p>octave 代码  <a href="https://github.com/real-cpf/octave-matlab" target="_blank" rel="noopener">https://github.com/real-cpf/octave-matlab</a></p>
</blockquote>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>octave</tag>
      </tags>
  </entry>
  <entry>
    <title>数值数组及向量化运算</title>
    <url>/2020/06/23/%E6%95%B0%E5%80%BC%E6%95%B0%E7%BB%84%E5%8F%8A%E5%90%91%E9%87%8F%E5%8C%96%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="用octave实现matlab的数值数组及向量化运算"><a href="#用octave实现matlab的数值数组及向量化运算" class="headerlink" title="用octave实现matlab的数值数组及向量化运算"></a>用octave实现matlab的数值数组及向量化运算</h2><blockquote>
<p>参考《精通matlab》</p>
</blockquote>
<a id="more"></a>

<iframe src="//player.bilibili.com/player.html?aid=371126131&bvid=BV1mZ4y1H7Vp&cid=205668031&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ol>
<li>一、二、、多维矩阵</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% (1,0)</span><br><span class="line">a1&#x3D;1:6					</span><br><span class="line">a2&#x3D;0:pi&#x2F;4:pi			</span><br><span class="line">a3&#x3D;1:-0.1:0	</span><br><span class="line"></span><br><span class="line">b1&#x3D;linspace(0,pi,4)		</span><br><span class="line">b2&#x3D;logspace(0,3,4)	 %10^a to 10^b</span><br><span class="line"></span><br><span class="line">% rng default  the &quot;rng&quot; function is not yet implemented in Octave</span><br><span class="line"></span><br><span class="line">c2&#x3D;rand(1,5)	</span><br><span class="line"></span><br><span class="line">%% (2,0)</span><br><span class="line"></span><br><span class="line">a&#x3D;2.7358; b&#x3D;33&#x2F;79;					</span><br><span class="line">C&#x3D;[1,2*a+i*b,b*sqrt(a);sin(pi&#x2F;4),a+5*b,3.5+i]  </span><br><span class="line"></span><br><span class="line">%% use variable editor </span><br><span class="line">A&#x3D;[]    %% edit add</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%% default array</span><br><span class="line"></span><br><span class="line">ao&#x3D;ones(2,4)				</span><br><span class="line">az&#x3D;zeros(2,5)				</span><br><span class="line">ae&#x3D;eye(3)					</span><br><span class="line">am&#x3D;magic(4)				</span><br><span class="line">ad&#x3D;diag(am)				</span><br><span class="line">add&#x3D;diag(diag(am))	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% rng default		</span><br><span class="line">Au&#x3D;rand(1,5)				</span><br><span class="line">Ai&#x3D;randi([-3,4],2,8)	</span><br><span class="line">% As&#x3D;randsrc(3,12,[-3,-1,1,3],1) %the &#39;randsrc&#39; function belongs to the communications package from Octave</span><br><span class="line">				</span><br><span class="line">Ap&#x3D;randperm(8)	</span><br><span class="line"></span><br><span class="line">% rng(0,&#39;v5normal&#39;)	 	</span><br><span class="line">randn(2,6)	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n&#x3D;5;lambda&#x3D;2;</span><br><span class="line">A &#x3D; gallery(&#39;jordbloc&#39;,n,lambda)	</span><br><span class="line"></span><br><span class="line">% rng(11,&#39;v5normal&#39;)						</span><br><span class="line">n&#x3D;6;										</span><br><span class="line">kappa&#x3D;1e8;								</span><br><span class="line">mode&#x3D;2;									</span><br><span class="line">B&#x3D; gallery(&#39;randsvd&#39;,n,kappa,mode)	</span><br><span class="line">Bsv&#x3D;svd(B)&#39;								</span><br><span class="line">Bc&#x3D;cond(B)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>矩阵属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">%% Dimension  Size</span><br><span class="line"></span><br><span class="line">A&#x3D;reshape(1:24,2,3,4);	</span><br><span class="line">dim_A&#x3D;ndims(A)			</span><br><span class="line">size_A&#x3D;size(A)			</span><br><span class="line">L_A&#x3D;length(A)		</span><br><span class="line"></span><br><span class="line">%% slices</span><br><span class="line">A&#x3D;zeros(2,6)		</span><br><span class="line">A(:)&#x3D;1:12			</span><br><span class="line">a8&#x3D;A(8)			</span><br><span class="line">a311&#x3D;A([3,11])	 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A(3,7)&#x3D;37			</span><br><span class="line">a13&#x3D;A(:,[1,3])	</span><br><span class="line">aend&#x3D;A([2,3],4:end)	</span><br><span class="line"></span><br><span class="line">L&#x3D;A&lt;3			</span><br><span class="line">A(L)&#x3D;NaN</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>矩阵操作</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% array ops</span><br><span class="line">a&#x3D;1:5;b&#x3D;6:10;c&#x3D;11:15;	</span><br><span class="line">a_b&#x3D;[a,b]					</span><br><span class="line">							</span><br><span class="line">ab&#x3D;[a;b;c]	</span><br><span class="line"></span><br><span class="line">AB1&#x3D;repmat(ab,[1,2])	</span><br><span class="line">AB2&#x3D;repmat(ab,[2,1])	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%% reshape</span><br><span class="line">a&#x3D;1:24;					</span><br><span class="line">A&#x3D;reshape(a,3,8)			</span><br><span class="line">B&#x3D;reshape(A,2,4,3)	</span><br><span class="line"></span><br><span class="line">Aud&#x3D;flipud(A)		</span><br><span class="line">Alr&#x3D;fliplr(A)		</span><br><span class="line">B1&#x3D;flipdim(A,1)	</span><br><span class="line">B2&#x3D;flipdim(A,2)	</span><br><span class="line">At&#x3D;A&#39;</span><br><span class="line"></span><br><span class="line">A90&#x3D;rot90(A)		</span><br><span class="line">A180&#x3D;rot90(A,2)	 </span><br><span class="line"></span><br><span class="line">A</span><br><span class="line">CR&#x3D;circshift(A,1)			</span><br><span class="line">CL&#x3D;circshift(A,[0,-1])	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%%  据电阻两端施加的电压，测量电阻中流过的电流，然后据测得的电压、电流计算平均电阻值。</span><br><span class="line"></span><br><span class="line">vr&#x3D;[0.89, 1.20, 3.09, 4.27, 3.62, 7.71, 8.99, 7.92, 9.70, 10.41];</span><br><span class="line">ir&#x3D;[0.028, 0.040, 0.100, 0.145, 0.118, 0.258, 0.299, 0.257, 0.308, 0.345];						</span><br><span class="line">L&#x3D;length(vr);					</span><br><span class="line">for k&#x3D;1:L</span><br><span class="line">	r(k)&#x3D;vr(k)&#x2F;ir(k);		</span><br><span class="line">end																		</span><br><span class="line">sr&#x3D;0;																	</span><br><span class="line">for k&#x3D;1:L</span><br><span class="line">	sr&#x3D;sr+r(k);				</span><br><span class="line">	end</span><br><span class="line">rm&#x3D;sr&#x2F;L			</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vr&#x3D;[0.89, 1.20, 3.09, 4.27, 3.62, 7.71, 8.99, 7.92, 9.70, 10.41];</span><br><span class="line">ir&#x3D;[0.028, 0.040, 0.100, 0.145, 0.118, 0.258, 0.299, 0.257, 0.308, 0.345];						</span><br><span class="line">r&#x3D;vr.&#x2F;ir		</span><br><span class="line">rm&#x3D;mean(r)	</span><br><span class="line"></span><br><span class="line">%% 在所有水平线和垂直线交点上计算函数z&#x3D;sin|xy|</span><br><span class="line"></span><br><span class="line">x&#x3D;-5:0.1:5;					</span><br><span class="line">y&#x3D;(-2.5:0.1:2.5)&#39;;			</span><br><span class="line">N&#x3D;length(x);					</span><br><span class="line">M&#x3D;length(y);					</span><br><span class="line">for ii&#x3D;1:M</span><br><span class="line">    for jj&#x3D;1:N</span><br><span class="line">        X0(ii,jj)&#x3D;x(jj);	</span><br><span class="line">        Y0(ii,jj)&#x3D;y(ii);	</span><br><span class="line">        Z0(ii,jj)&#x3D;sin(abs(x(jj)*y(ii)));</span><br><span class="line">    end</span><br><span class="line">end  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[X,Y]&#x3D;meshgrid(x,y);		</span><br><span class="line">Z&#x3D;sin(abs(X.*Y));	</span><br><span class="line"></span><br><span class="line">norm(Z-Z0)</span><br><span class="line"></span><br><span class="line">surf(X,Y,Z)</span><br><span class="line">xlabel(&#39;x&#39;)</span><br><span class="line">ylabel(&#39;y&#39;)</span><br><span class="line">shading interp</span><br><span class="line">view([190,70])</span><br></pre></td></tr></table></figure>
<img src="/2020/06/23/%E6%95%B0%E5%80%BC%E6%95%B0%E7%BB%84%E5%8F%8A%E5%90%91%E9%87%8F%E5%8C%96%E8%BF%90%E7%AE%97/tu1.png" class="" title="在所有水平线和垂直线交点上计算函数z&#x3D;sin|xy|">

<ol start="4">
<li><p>“和”、“积”、“累和”、“累积”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">%% 数组元素的“和”、“积”、“累和”、“累积”运算。</span><br><span class="line"></span><br><span class="line">% rng default		</span><br><span class="line">a&#x3D;[(1:5)&#39;,randi(5,[5,3]),randn(5,2)]				</span><br><span class="line">cs&#x3D;cumsum(a)		</span><br><span class="line">s&#x3D;sum(a)			</span><br><span class="line">cp&#x3D;cumprod(a)  	</span><br><span class="line">p&#x3D;prod(a)		</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% rng(50,&#39;v5normal&#39;)				</span><br><span class="line">a&#x3D;randn(1,3),b&#x3D;randn(1,3),		</span><br><span class="line">c&#x3D;dot(a,b)						</span><br><span class="line">d&#x3D;cross(a,b)		</span><br><span class="line"></span><br><span class="line">ab&#x3D;[a;b];</span><br><span class="line">dd(1)&#x3D;det(ab(:,[2,3]));</span><br><span class="line">dd(2)&#x3D;-det(ab(:,[1,3]));</span><br><span class="line">dd(3)&#x3D;det(ab(:,[1,2])); </span><br><span class="line">dd		</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plot3([0;a(1)],[0;a(2)],[0;a(3)],&#39;b--&#39;,&#39;LineWidth&#39;,3)	</span><br><span class="line">hold on</span><br><span class="line">plot3([0;b(1)],[0;b(1)],[0;b(3)],&#39;g-.&#39;,&#39;LineWidth&#39;,3)	</span><br><span class="line">plot3([0;d(1)],[0;d(2)],[0;d(3)],&#39;r&#39;,&#39;LineWidth&#39;,3)		</span><br><span class="line">hold off</span><br><span class="line">grid on</span><br><span class="line">box on</span><br><span class="line">view([131,-4])</span><br><span class="line">legend(&#39;\bfa&#39;,&#39;\bfb&#39;,&#39;\bfd &#x3D; &#123;\bfa&#125; &#123;\times&#125; &#123;\bfb&#125;&#39;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>高维数组</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">%% 高维数组的孤维删除</span><br><span class="line"></span><br><span class="line">A&#x3D;reshape(1:24,[1,3,4,1,2]);	</span><br><span class="line">SA&#x3D;size(A)						</span><br><span class="line">B&#x3D;squeeze(A)		</span><br><span class="line"></span><br><span class="line">[Am,m]&#x3D;shiftdim(A)		</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A3&#x3D;shiftdim(Am,3)		</span><br><span class="line"></span><br><span class="line">Am(:,:,:,1)&#x3D;[]			  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%% 高维数组的维度重排</span><br><span class="line"></span><br><span class="line">A&#x3D;reshape(1:24,[2,4,3])		  </span><br><span class="line"></span><br><span class="line">DimOrder&#x3D;[3,2,1];</span><br><span class="line">B&#x3D;permute(A,DimOrder) 	</span><br><span class="line">AA&#x3D;ipermute(B,DimOrder)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C&#x3D;reshape(A,[3,4,2])</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>“非数”和“空”数组</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">%% “非数”和“空”数组</span><br><span class="line"></span><br><span class="line">a&#x3D;0&#x2F;0,b&#x3D;0*log(0),c&#x3D;inf-inf  </span><br><span class="line">0*a,sin(a) </span><br><span class="line">class(a)		</span><br><span class="line">isnan(a)	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% rng default	</span><br><span class="line">R&#x3D;rand(2,5);R(2,3)&#x3D;NaN;R(1,5)&#x3D;NaN  </span><br><span class="line">LR&#x3D;isnan(R)	</span><br><span class="line"></span><br><span class="line">si&#x3D;find(LR);						</span><br><span class="line">[ri,ci]&#x3D;ind2sub(size(R),si);	</span><br><span class="line">disp(&#39;非数位置的单下标标识&#39;)</span><br><span class="line">disp([&#39;第&#39;,int2str(si(1)),&#39;和第&#39;,int2str(si(2)),&#39;个元素&#39;])</span><br><span class="line">disp(&#39; &#39;)</span><br><span class="line">disp(&#39;非数位置的双下标标识&#39;)</span><br><span class="line">disp([&#39;第 &#39;,mat2str([ri(1),ci(1)],2),&#39; 元素&#39;])</span><br><span class="line">disp([&#39;第 &#39;,mat2str([ri(2),ci(2)],2),&#39; 元素&#39;])  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[rj,cj]&#x3D;find(LR);		</span><br><span class="line">disp(&#39;非数位置的双下标标识&#39;)</span><br><span class="line">disp([&#39;第 &#39;,mat2str([rj(1),cj(1)],2),&#39; 元素&#39;])</span><br><span class="line">disp([&#39;第 &#39;,mat2str([rj(2),cj(2)],2),&#39; 元素&#39;])  </span><br><span class="line"></span><br><span class="line">%% empty array </span><br><span class="line">a&#x3D;[]</span><br><span class="line">b&#x3D;ones(2,0),c&#x3D;zeros(2,0),d&#x3D;eye(2,0)</span><br><span class="line">f&#x3D;rand(2,3,0,4)  </span><br><span class="line"></span><br><span class="line">class(a)			</span><br><span class="line">isnumeric(a)		</span><br><span class="line">isempty(a)	</span><br><span class="line"></span><br><span class="line">which a 			</span><br><span class="line">ndims(a)			</span><br><span class="line">size(a)	</span><br><span class="line"></span><br><span class="line">A&#x3D;reshape(-4:5,2,5) </span><br><span class="line"></span><br><span class="line">A(:,[2,4])&#x3D;[]</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>关系运算与逻辑操作</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">%% 关系运算</span><br><span class="line"></span><br><span class="line">t&#x3D;-3*pi:pi&#x2F;10:3*pi;	</span><br><span class="line">y&#x3D;sin(t).&#x2F;t;			</span><br><span class="line">tt&#x3D;t+(t&#x3D;&#x3D;0)*eps;		</span><br><span class="line">yy&#x3D;sin(tt).&#x2F;tt;		</span><br><span class="line">subplot(1,2,1),plot(t,y),axis([-9,9,-0.5,1.2]),</span><br><span class="line">xlabel(&#39;t&#39;),ylabel(&#39;y&#39;),title(&#39;残缺图形&#39;)</span><br><span class="line">subplot(1,2,2),plot(tt,yy),axis([-9,9,-0.5,1.2])</span><br><span class="line">xlabel(&#39;tt&#39;),ylabel(&#39;yy&#39;),title(&#39;正确图形&#39;)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%%  逻辑操作</span><br><span class="line"></span><br><span class="line">A&#x3D;[-2,-1,0,0,1,2,3]</span><br><span class="line">L1&#x3D;~(A&gt;1)				</span><br><span class="line">L2&#x3D;(A&gt;0)&amp;(A&lt;2)	</span><br><span class="line"></span><br><span class="line">A,B&#x3D;[0,-1,1,0,1,-2,-3]</span><br><span class="line">C&#x3D;xor(A,B)	 </span><br><span class="line"></span><br><span class="line">%% sint 削顶半波整流波形 </span><br><span class="line"></span><br><span class="line">clear,t&#x3D;linspace(0,3*pi,500);y&#x3D;sin(t);</span><br><span class="line">z1&#x3D;((t&lt;pi)|(t&gt;2*pi)).*y;					%	&lt;3&gt;</span><br><span class="line">w&#x3D;(t&gt;pi&#x2F;3&amp;t&lt;2*pi&#x2F;3)+(t&gt;7*pi&#x2F;3&amp;t&lt;8*pi&#x2F;3);%	&lt;4&gt;</span><br><span class="line">wn&#x3D;~w;																	%	&lt;5&gt;</span><br><span class="line">z2&#x3D;w*sin(pi&#x2F;3)+wn.*z1;						%	&lt;6&gt;</span><br><span class="line">subplot(4,1,1),plot(t,y,&#39;:r&#39;),axis([0,10,-1.5,1.5])</span><br><span class="line">ylabel(&#39;y&#39;),grid on</span><br><span class="line">subplot(4,1,2),plot(t,z1,&#39;:r&#39;),axis([0,10,-0.2,1.5]),ylabel(&#39;z1&#39;)</span><br><span class="line">subplot(4,1,3),plot(t,wn,&#39;:r&#39;),axis([0,10,-0.2,1.5]),ylabel(&#39;wn&#39;)</span><br><span class="line">subplot(4,1,4),plot(t,z2,&#39;-b&#39;),axis([0,10,-0.2,1.5]),ylabel(&#39;z2&#39;)</span><br><span class="line">xlabel(&#39;t&#39;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>octave</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串、胞元和构架数组</title>
    <url>/2020/07/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E8%83%9E%E5%85%83%E5%92%8C%E6%9E%84%E6%9E%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="字符串、胞元和构架数组"><a href="#字符串、胞元和构架数组" class="headerlink" title="字符串、胞元和构架数组"></a>字符串、胞元和构架数组</h2><blockquote>
<p>参考《精通matlab》</p>
</blockquote>
<a id="more"></a>



<img src="/2020/07/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E8%83%9E%E5%85%83%E5%92%8C%E6%9E%84%E6%9E%B6%E6%95%B0%E7%BB%84/31.png" class="" title="MATLAB的数据类型">


<iframe src="//player.bilibili.com/player.html?aid=201125003&bvid=BV1az411e7cQ&cid=208383204&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ol>
<li><p>3.2.1串数组的属性和标识</p>
<blockquote>
<p>a=’This is an example.’<br>size(a)<br>a14=a(1:4)<br>ra=a(end:-1:1)<br>Ua=double(a)<br>char(Ua)<br>w=find(a&gt;=’a’&amp;a&lt;=’z’);<br>Ua(w)=Ua(w)-32;<br>char(Ua)<br>A=’这是一个算例。’;<br>A_s=size(A)<br>A56=A([5 6])<br>UCA=double(A)    </p>
</blockquote>
</li>
<li><p>复杂串数组的创建</p>
<blockquote>
<p>S=[‘This string array ‘<br>‘has multiple rows.’]<br>size(S) </p>
</blockquote>
</li>
<li><p>串转换函数</p>
<blockquote>
<p>S1=char(‘This string array’,’has two rows.’)<br>size(S1)<br>S2=str2mat(‘这’,’字符’,’串数组’,’’,’由4行组成’)<br>size(S2)<br>C1={‘MATLAB201xa includes data types:’;<br>‘◆Double array’;<br>‘◆Character array’;<br>‘and so on’}<br>C1_c=class(C1)<br>size(C1)<br>C2=char(‘MATLAB201xa includes data types:’,…<br>‘◆Double array’,…<br>‘◆Character array’,…<br>‘and so on’)<br>C2_c=class(C2)<br>size(C2)<br>C3=cellstr(C2)<br>size(C3)<br>A=eye(2,4);<br>A_str1=int2str(A)<br>a=rand(2,2);<br>s1=num2str(a)<br>s_s=sprintf(‘%.10e\n’,a)<br>fprintf(‘%.5g\‘,a)<br>s_str2=str2num(s_s)<br>s_sscan=sscanf(s_s,’%f’,[3,2]) </p>
</blockquote>
</li>
<li><p>构架数组域</p>
<blockquote>
<p>A(1,1).name=’Wang Pin-pin’; A(1,1).phonenumber=85436789;<br>A(1,2).name={‘Lin Beng-ming’};A(1,2).phonenumber=61125568;<br>A(2,1).name=’Zhang Qing’;A(2,1).phonenumber=83492567;<br>A(2,2).name(2)={‘Yu Dong-jin’};A(2,2).phonenumber(2)=61125569;<br>A(1,3).name={‘Zhao Zhong-xin’};A(1,3).phonenumber=54681123;<br>A(1,3).name(2)={‘Mao Li-xiu’};A(1,3).phonenumber(2)=54681124;<br>disp(‘域名’),disp(fieldnames(A))<br>disp(‘大小’),disp(size(A))  </p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>octave</tag>
      </tags>
  </entry>
  <entry>
    <title>数值计算-1</title>
    <url>/2020/07/21/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97-1/</url>
    <content><![CDATA[<h2 id="数值计算-1"><a href="#数值计算-1" class="headerlink" title="数值计算-1"></a>数值计算-1</h2><blockquote>
<p>参考《精通matlab》</p>
</blockquote>
<a id="more"></a>

<ol>
<li><p>数值微积分</p>
<ul>
<li><p>求函数极限 </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">k&#x3D;logspace(0,14,15);	</span><br><span class="line">x&#x3D;k*eps;					</span><br><span class="line">f1&#x3D;(1-cos(2.*x)).&#x2F;x.&#x2F;sin(x)&#x2F;2;</span><br><span class="line">f2&#x3D;sin(x).&#x2F;x;</span><br><span class="line">format short e</span><br><span class="line">disp([blanks(7),&#39;x&#39;,blanks(11),&#39;f1&#39;,blanks(11),&#39;f2&#39;])</span><br><span class="line">disp([x&#39;,f1&#39;,f2&#39;])		</span><br><span class="line">clf							</span><br><span class="line">n1&#x3D;sum(f1&lt;10^-10);		</span><br><span class="line">subplot(2,1,1)</span><br><span class="line">semilogx(x(1:n1),f1(1:n1),&#39;ro&#39;,&#39;LineWidth&#39;,3)				</span><br><span class="line">hold on</span><br><span class="line">semilogx(x(n1+1:end),f1(n1+1:end),&#39;b.-&#39;,&#39;LineWidth&#39;,3)	</span><br><span class="line">hold off</span><br><span class="line">text(10^-14,0.2,&#39;错误区段&#39;),text(10^-6,0.8,&#39;正确区段&#39;)</span><br><span class="line">axis([10^-20,1,0,1.1])</span><br><span class="line">grid on</span><br><span class="line">title(&#39;f2&#39;)</span><br><span class="line">subplot(2,1,2)</span><br><span class="line">semilogx(x,f2,&#39;b.-&#39;,&#39;LineWidth&#39;,3)</span><br><span class="line">axis([10^-20,1,0,1.1])</span><br><span class="line">title(&#39;f1&#39;)</span><br><span class="line">xlabel(&#39;x&#39;)</span><br><span class="line">grid on</span><br><span class="line">shg</span><br></pre></td></tr></table></figure>
 <img src="/2020/07/21/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97-1/p1.png" class="" title="图1">
</li>
<li><p>数值差分</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clf</span><br><span class="line">h&#x3D;0.5;					</span><br><span class="line">x&#x3D;0:h:3;				</span><br><span class="line">f&#x3D;4-(x-2).^2;			</span><br><span class="line">df&#x3D;diff(f);			</span><br><span class="line">gf&#x3D;gradient(f);		</span><br><span class="line">subplot(2,1,1)	</span><br><span class="line">hold on				</span><br><span class="line">plot(x,f,&#39;r.-&#39;)		</span><br><span class="line">x1&#x3D;x(1:end-1);		</span><br><span class="line">plot(x1,df,&#39;bo-&#39;)	</span><br><span class="line">legend(&#39;f&#39;,&#39;df&#39;)		</span><br><span class="line">text(1,3.4,&#39;f3&#39;),text(1.5,4.2,&#39;f4&#39;)		</span><br><span class="line">text(1.05,1.1,&#39;df3&#x3D;f4 - f3&#39;)</span><br><span class="line">axis([-1,4,-2,5])	</span><br><span class="line">xlabel(&#39;x&#39;)			</span><br><span class="line">box on					</span><br><span class="line">hold off				</span><br><span class="line">subplot(2,1,2)	</span><br><span class="line">hold on</span><br><span class="line">plot(x,f,&#39;r.-&#39;)		</span><br><span class="line">plot(x1,df,&#39;bo-&#39;)	</span><br><span class="line">plot(x,gf,&#39;k*-&#39;)		</span><br><span class="line">legend(&#39;f&#39;,&#39;df&#39;,&#39;gf&#39;)</span><br><span class="line">text(0,-0.5,&#39;f1&#39;),text(2.9,2.4,&#39;f7&#39;)</span><br><span class="line">text(-0.45,2.2,&#39;gf1&#x3D;f2 - f1&#39;),text(3,-0.3,&#39;gf7&#x3D;f7 - f6&#39;)</span><br><span class="line">text(0.5,2.3,&#39;f2&#39;),text(1.5,4.2,&#39;f4&#39;)</span><br><span class="line">text(1.05,1.3,&#39;gf3&#x3D;(f4 - f2) &#x2F;2&#39;)</span><br><span class="line">axis([-1,4,-2,5])</span><br><span class="line">xlabel(&#39;x&#39;)</span><br><span class="line">box on</span><br><span class="line">hold off</span><br><span class="line">shg</span><br></pre></td></tr></table></figure>
  <img src="/2020/07/21/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97-1/p2.png" class="" title="图2"></li>
<li><p>一元函数积分</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">format long</span><br><span class="line">a&#x3D;1.5;</span><br><span class="line">y1&#x3D;@(t)cos(1.&#x2F;(a*t.^2));			</span><br><span class="line">S1&#x3D;quad(y1,0.2,0.3)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">y2&#x3D;@(t)exm040203_chirp(t,a);		</span><br><span class="line">S2&#x3D;quad(y2,0.2,0.3)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">y3&#x3D;inline(&#39;cos(1.&#x2F;(a*t.^2))&#39;,&#39;t&#39;,&#39;a&#39;);	</span><br><span class="line">S3&#x3D;quad(y3,0.2,0.3,[],[],a)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">format long</span><br><span class="line">f1&#x3D;@(x)sqrt(x);			</span><br><span class="line">f2&#x3D;@(x)x.^3;				</span><br><span class="line">s1&#x3D;quad(f1,0,1);</span><br><span class="line">s2&#x3D;quad(f2,0,1);</span><br><span class="line">S&#x3D;s1-s2  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f&#x3D;@(x)[sqrt(x),x.^3];	</span><br><span class="line">s&#x3D;quadv(f,0,1);			</span><br><span class="line">Sv&#x3D;s(1)-s(2)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>矩阵计算</p>
<ul>
<li>奇异值分解  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load .&#x2F;mfile&#x2F;exm040303_data</span><br><span class="line">--------------------------------</span><br><span class="line">0.54334	0.44498	0.84237	-0.65633	0.067256</span><br><span class="line">0.6386	0.85166	1.3861	-0.59102	0.078485</span><br><span class="line">-0.13477	-0.21742	-0.45568	0.20241	-0.082092</span><br><span class="line">-0.59188	-0.67615	-1.0381	0.52112	-0.010908</span><br><span class="line">0.049152	0.21892	0.3352	0.0035418	0.030404</span><br><span class="line">0.25843	0.66082	1.0254	-0.1392	0.076908</span><br><span class="line">------------------------------</span><br><span class="line">format short g</span><br><span class="line">[U,S,V]&#x3D;svd(A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s&#x3D;diag(S);</span><br><span class="line">n&#x3D;length(s);</span><br><span class="line">plot(1:n,s,&#39;-k&#39;,1:n,s,&#39;.k&#39;,&#39;MarkerSize&#39;,20)</span><br><span class="line">xlabel(&#39;1----&gt;n&#39;)</span><br><span class="line">ylabel(&#39;Sigular values&#39;)</span><br><span class="line">title(&#39;Sigular values of matrix A&#39;) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A_rank0&#x3D;rank(A)				</span><br><span class="line">A_null0&#x3D;null(A)  </span><br><span class="line"></span><br><span class="line">dw&#x3D;0.001;					</span><br><span class="line">A_rank_noise&#x3D;rank(A,3*dw*S(1,1)*length(A))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ar&#x3D;U(:,1:A_rank_noise)*diag(s(1:A_rank_noise))*V(:,1:A_rank_noise)&#39;</span><br><span class="line">df&#x3D;S(4,4)^2+S(5,5)^2		</span><br><span class="line">ds&#x3D;sqrt(df)					</span><br><span class="line">da&#x3D;max(max(abs(A-Ar)))</span><br></pre></td></tr></table></figure>
   <img src="/2020/07/21/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97-1/p3.png" class="" title="图3"></li>
</ul>
</li>
<li><p>随机变量的产生及其特征描述</p>
<ul>
<li>随机数的产生及重现控制  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">r1&#x3D;rand(1,3)				</span><br><span class="line">r2&#x3D;randn(1,4)				</span><br><span class="line">r3&#x3D;randi([-8,8],3,10)	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N&#x3D;10000;</span><br><span class="line">a&#x3D;randn(N+2,1);					</span><br><span class="line">A&#x3D;[a(1:N),a(2:N+1),a(3:N+2)];	</span><br><span class="line">A(1:4,:)							</span><br><span class="line">CA&#x3D;cov(A)							</span><br><span class="line">nh&#x3D;7*log10(N);					</span><br><span class="line"></span><br><span class="line">subplot(1,3,1),histfit(A(:,1),nh),title(&#39;A(:,1)&#39;)</span><br><span class="line">subplot(1,3,2),histfit(A(:,2),nh),title(&#39;A(:,2)&#39;)</span><br><span class="line">subplot(1,3,3),histfit(A(:,3),nh),title(&#39;A(:,3)&#39;)  </span><br><span class="line"></span><br><span class="line">clear</span><br><span class="line">RS&#x3D;RandStream(&#39;mlfg6331_64&#39;);	</span><br><span class="line">N&#x3D;10000;</span><br><span class="line">A1&#x3D;zeros(3,5);AA1&#x3D;A1;</span><br><span class="line">B&#x3D;zeros(N,3);</span><br><span class="line">for k&#x3D;1:3</span><br><span class="line">    set(RS,&#39;Substream&#39;,k)		</span><br><span class="line">    A1(k,:)&#x3D;rand(RS,1,5);		</span><br><span class="line">    B(:,k)&#x3D;rand(RS,N,1);		</span><br><span class="line">end</span><br><span class="line">for k&#x3D;1:3</span><br><span class="line">    set(RS,&#39;Substream&#39;,k)</span><br><span class="line">    AA1(k,:)&#x3D;rand(RS,1,5);</span><br><span class="line">end</span><br><span class="line">A1,AA1</span><br><span class="line">rA&#x3D;corrcoef(B)					</span><br><span class="line">nh&#x3D;5*log10(N);					</span><br><span class="line">subplot(1,3,1),hist(B(:,1),nh),title(&#39;B(:,1)&#39;)</span><br><span class="line">subplot(1,3,2),hist(B(:,2),nh),title(&#39;B(:,2)&#39;)</span><br><span class="line">subplot(1,3,3),hist(B(:,3),nh),title(&#39;B(:,3)&#39;)</span><br></pre></td></tr></table></figure>
  <img src="/2020/07/21/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97-1/p4.png" class="" title="图4"></li>
</ul>
</li>
</ol>
<ul>
<li>未完待续……</li>
</ul>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>octave</tag>
      </tags>
  </entry>
</search>
